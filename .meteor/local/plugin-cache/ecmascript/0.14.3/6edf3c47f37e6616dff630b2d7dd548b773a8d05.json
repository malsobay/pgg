{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/players/methods.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/empirica:core/api/players/methods.js","filename":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/players/methods.js","passPerPreset":false,"envName":"development","cwd":"/Users/tilenbabnik/Desktop/pgg","root":"/Users/tilenbabnik/Desktop/pgg","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.9.2","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/players/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/empirica:core/api/players/methods.js"}},"code":"module.export({\n  createPlayer: () => createPlayer,\n  playerReady: () => playerReady,\n  updatePlayerData: () => updatePlayerData,\n  markPlayerExitStepDone: () => markPlayerExitStepDone,\n  extendPlayerTimeoutWait: () => extendPlayerTimeoutWait,\n  endPlayerTimeoutWait: () => endPlayerTimeoutWait,\n  earlyExitPlayer: () => earlyExitPlayer,\n  earlyExitPlayerLobby: () => earlyExitPlayerLobby,\n  retireSinglePlayer: () => retireSinglePlayer,\n  retireGameFullPlayers: () => retireGameFullPlayers,\n  playerWasRetired: () => playerWasRetired,\n  updatePlayerStatus: () => updatePlayerStatus\n});\nlet ValidatedMethod;\nmodule.link(\"meteor/mdg:validated-method\", {\n  ValidatedMethod(v) {\n    ValidatedMethod = v;\n  }\n\n}, 0);\nlet SimpleSchema;\nmodule.link(\"simpl-schema\", {\n  default(v) {\n    SimpleSchema = v;\n  }\n\n}, 1);\nlet Batches;\nmodule.link(\"../batches/batches.js\", {\n  Batches(v) {\n    Batches = v;\n  }\n\n}, 2);\nlet GameLobbies;\nmodule.link(\"../game-lobbies/game-lobbies\", {\n  GameLobbies(v) {\n    GameLobbies = v;\n  }\n\n}, 3);\nlet IdSchema;\nmodule.link(\"../default-schemas.js\", {\n  IdSchema(v) {\n    IdSchema = v;\n  }\n\n}, 4);\nlet LobbyConfigs;\nmodule.link(\"../lobby-configs/lobby-configs.js\", {\n  LobbyConfigs(v) {\n    LobbyConfigs = v;\n  }\n\n}, 5);\nlet Games;\nmodule.link(\"../games/games.js\", {\n  Games(v) {\n    Games = v;\n  }\n\n}, 6);\nlet Players;\nmodule.link(\"./players\", {\n  Players(v) {\n    Players = v;\n  }\n\n}, 7);\nlet exitStatuses;\nmodule.link(\"./players.js\", {\n  exitStatuses(v) {\n    exitStatuses = v;\n  }\n\n}, 8);\nlet sleep, weightedRandom;\nmodule.link(\"../../lib/utils.js\", {\n  sleep(v) {\n    sleep = v;\n  },\n\n  weightedRandom(v) {\n    weightedRandom = v;\n  }\n\n}, 9);\nlet shared;\nmodule.link(\"../../shared.js\", {\n  default(v) {\n    shared = v;\n  }\n\n}, 10);\nlet gameLobbyLock;\nmodule.link(\"../../gameLobby-lock.js\", {\n  default(v) {\n    gameLobbyLock = v;\n  }\n\n}, 11);\nconst createPlayer = new ValidatedMethod({\n  name: \"Players.methods.create\",\n  validate: new SimpleSchema({\n    id: {\n      type: String\n    },\n    urlParams: {\n      type: Object,\n      blackbox: true,\n      defaultValue: {}\n    }\n  }).validator(),\n\n  run(player) {\n    // Find the first running batch (in order of running started time)\n    const batch = Batches.findOne({\n      status: \"running\",\n      full: false\n    }, {\n      sort: {\n        runningAt: 1\n      }\n    });\n\n    if (!batch) {\n      // The UI should update and realize there is no batch available\n      // This should be a rare case where a fraction of a second of\n      // desynchornisation when the last available batch just finished.\n      // If this is the case, since the user exist in the DB at this point\n      // but has no lobby assigned, and the UI will soon determine there\n      // is no available game, the UI will switch to \"No experiments\n      // available\", nothing else to do.\n      return;\n    } // TODO: MAYBE, add verification that the user is not current connected\n    // elsewhere and this is not a flagrant impersonation. Note that is\n    // extremely difficult to guaranty. Could also add verification of user's\n    // id with email verication for example. For now the assumption is that\n    // there is no immediate reason or long-term motiviation for people to hack\n    // each other's player account.\n\n\n    const existing = Players.findOne({\n      id: player.id\n    }); // If the player already has a game lobby assigned, no need to\n    // re-initialize them\n\n    if (existing && existing.gameLobbyId) {\n      return existing._id;\n    }\n\n    if (existing) {\n      player = existing;\n    } else {\n      // Because of a bug in SimpleSchema around blackbox: true, skipping\n      // validation here. Validation did happen at the method level though.\n      player._id = Players.insert(player, {\n        filter: false,\n        validate: false\n      });\n    } // Looking for all lobbies for batch (for which that game has not started yet)\n\n\n    const lobbies = GameLobbies.find({\n      batchId: batch._id,\n      status: \"running\",\n      timedOutAt: {\n        $exists: false\n      },\n      gameId: {\n        $exists: false\n      }\n    }).fetch();\n\n    if (lobbies.length === 0) {\n      // This is the same case as when there are no batches available.\n      return;\n    } // Let's first try to find lobbies for which their queue isn't full yet\n\n\n    let lobbyPool = lobbies.filter(l => l.availableCount > l.queuedPlayerIds.length); // If no lobbies still have \"availability\", just fill any lobby\n\n    if (lobbyPool.length === 0) {\n      lobbyPool = lobbies;\n    } // Book proportially to total expected playerCount\n\n\n    const weigthedLobbyPool = lobbyPool.map(lobby => {\n      return {\n        value: lobby,\n        weight: lobby.availableCount\n      };\n    }); // Choose a lobby in the available weigthed pool\n\n    const lobby = weightedRandom(weigthedLobbyPool)(); // Adding the player to specified lobby queue\n\n    GameLobbies.update(lobby._id, {\n      $addToSet: {\n        queuedPlayerIds: player._id\n      }\n    });\n    const gameLobbyId = lobby._id;\n    const $set = {\n      gameLobbyId\n    }; // Check if there will be instructions\n\n    let skipInstructions = lobby.debugMode; // If there are no instruction, mark the player as ready immediately\n\n    if (skipInstructions) {\n      $set.readyAt = new Date();\n    }\n\n    Players.update(player._id, {\n      $set\n    }); // If there are no instruction, player is ready, notify the lobby\n\n    if (skipInstructions) {\n      GameLobbies.update(gameLobbyId, {\n        $addToSet: {\n          playerIds: player._id\n        }\n      });\n    }\n\n    return player._id;\n  }\n\n});\nconst playerReady = new ValidatedMethod({\n  name: \"Players.methods.ready\",\n  validate: IdSchema.validator(),\n\n  run(_ref) {\n    return Promise.asyncApply(() => {\n      let {\n        _id\n      } = _ref;\n\n      if (!Meteor.isServer) {\n        return;\n      }\n\n      try {\n        // Lobby might be locked if game is currently being created.\n        // We retry until lobby is unlocked.\n        while (!assignToLobby(_id)) {\n          Promise.await(sleep(1000));\n        }\n      } catch (error) {\n        console.error(\"Players.methods.ready\", error);\n      }\n    });\n  }\n\n});\n\nfunction assignToLobby(_id) {\n  const player = Players.findOne(_id);\n\n  if (!player) {\n    throw \"unknown ready player: \".concat(_id);\n  }\n\n  const {\n    readyAt,\n    gameLobbyId\n  } = player;\n\n  if (readyAt) {\n    // Already ready\n    return true;\n  }\n\n  const lobby = GameLobbies.findOne(gameLobbyId);\n\n  if (!lobby) {\n    throw \"unknown lobby for ready player: \".concat(_id);\n  } // GameLobby is locked.\n\n\n  if (gameLobbyLock[gameLobbyId]) {\n    return false;\n  } // Game is Full, bail the player\n\n\n  if (lobby.playerIds.length === lobby.availableCount) {\n    // User already ready, something happened out of order\n    if (lobby.playerIds.includes(_id)) {\n      return true;\n    } // Mark the player's participation attemp as failed if\n    // not already marked exited\n\n\n    Players.update({\n      _id,\n      exitAt: {\n        $exists: false\n      }\n    }, {\n      $set: {\n        exitAt: new Date(),\n        exitStatus: \"gameFull\"\n      }\n    });\n    return true;\n  } // Try to update the GameLobby with the playerIds we just queried.\n\n\n  GameLobbies.update({\n    _id: gameLobbyId,\n    playerIds: lobby.playerIds\n  }, {\n    $addToSet: {\n      playerIds: _id\n    }\n  }); // If the playerId insert succeeded (playerId WAS added to playerIds),\n  // mark the user record as ready and potentially start the individual\n  // lobby timer.\n\n  const lobbyUpdated = GameLobbies.findOne(gameLobbyId);\n\n  if (lobbyUpdated.playerIds.includes(_id)) {\n    // If it did work, mark player as ready\n    $set = {\n      readyAt: new Date()\n    }; // If it's an individual lobby timeout, mark the first timer as started.\n\n    const lobbyConfig = LobbyConfigs.findOne(lobbyUpdated.lobbyConfigId);\n\n    if (lobbyConfig.timeoutType === \"individual\") {\n      $set.timeoutStartedAt = new Date();\n      $set.timeoutWaitCount = 1;\n    }\n\n    Players.update(_id, {\n      $set\n    });\n    return true;\n  } // If the playerId insert failed (playerId NOT added to playerIds), the\n  // playerIds has changed since it was queried and the lobby might not\n  // have any available slots left, loop and retry.\n\n\n  return false;\n}\n\nconst updatePlayerData = new ValidatedMethod({\n  name: \"Players.methods.updateData\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    key: {\n      type: String\n    },\n    value: {\n      type: String\n    },\n    append: {\n      type: Boolean,\n      optional: true\n    },\n    noCallback: {\n      type: Boolean,\n      optional: true\n    }\n  }).validator(),\n\n  run(_ref2) {\n    let {\n      playerId,\n      key,\n      value,\n      append,\n      noCallback\n    } = _ref2;\n    const player = Players.findOne(playerId);\n\n    if (!player) {\n      throw new Error(\"player not found\");\n    } // TODO check can update this record player\n\n\n    const val = JSON.parse(value);\n    let update = {\n      [\"data.\".concat(key)]: val\n    };\n    const modifier = append ? {\n      $push: update\n    } : {\n      $set: update\n    };\n    Players.update(playerId, modifier, {\n      autoConvert: false,\n      filter: false,\n      validate: false,\n      trimStrings: false,\n      removeEmptyStrings: false\n    });\n\n    if (Meteor.isServer && !noCallback) {\n      shared.callOnChange({\n        playerId,\n        player,\n        key,\n        value: val,\n        prevValue: player.data && player.data[key],\n        append\n      });\n    }\n  }\n\n});\nconst markPlayerExitStepDone = new ValidatedMethod({\n  name: \"Players.methods.markExitStepDone\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    stepName: {\n      type: String\n    }\n  }).validator(),\n\n  run(_ref3) {\n    let {\n      playerId,\n      stepName\n    } = _ref3;\n    const player = Players.findOne(playerId);\n\n    if (!player) {\n      throw new Error(\"player not found\");\n    } // TODO check can update this record player\n\n\n    Players.update(playerId, {\n      $addToSet: {\n        exitStepsDone: stepName\n      }\n    });\n  }\n\n});\nconst extendPlayerTimeoutWait = new ValidatedMethod({\n  name: \"Players.methods.extendTimeoutWait\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run(_ref4) {\n    let {\n      playerId\n    } = _ref4;\n    const player = Players.findOne(playerId);\n\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n\n    Players.update(playerId, {\n      $inc: {\n        timeoutWaitCount: 1\n      },\n      $set: {\n        timeoutStartedAt: new Date()\n      }\n    });\n  }\n\n});\nconst endPlayerTimeoutWait = new ValidatedMethod({\n  name: \"Players.methods.endTimeoutWait\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run(_ref5) {\n    let {\n      playerId\n    } = _ref5;\n    const player = Players.findOne(playerId);\n\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitStatus: \"playerEndedLobbyWait\",\n        exitAt: new Date()\n      }\n    });\n    GameLobbies.update(player.gameLobbyId, {\n      $pull: {\n        playerIds: playerId // We keep the player in queuedPlayerIds so they will still have the\n        // fact they were in a lobby available in the UI, and so we can show\n        // them the exit steps.\n\n      }\n    });\n  }\n\n});\nconst earlyExitPlayer = new ValidatedMethod({\n  name: \"Players.methods.admin.earlyExitPlayer\",\n  validate: new SimpleSchema({\n    exitReason: {\n      label: \"Reason for Exit\",\n      type: String,\n      regEx: /[a-zA-Z0-9_]+/\n    },\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    gameId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run(_ref6) {\n    let {\n      exitReason,\n      playerId,\n      gameId\n    } = _ref6;\n\n    if (!Meteor.isServer) {\n      return;\n    }\n\n    const game = Games.findOne(gameId);\n\n    if (!game) {\n      throw new Error(\"game not found\");\n    }\n\n    if (game && game.finishedAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\n\\ngame already ended!\");\n      }\n\n      return;\n    }\n\n    const currentPlayer = Players.findOne(playerId);\n\n    if (currentPlayer && currentPlayer.exitAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nplayer already exited!\");\n      }\n\n      return;\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitAt: new Date(),\n        exitStatus: \"custom\",\n        exitReason\n      }\n    });\n    const players = Players.find({\n      gameId\n    }).fetch();\n    const onlinePlayers = players.filter(player => !player.exitAt);\n\n    if (!onlinePlayers || onlinePlayers && onlinePlayers.length === 0) {\n      Games.update(gameId, {\n        $set: {\n          finishedAt: new Date(),\n          status: \"custom\",\n          endReason: \"finished_early\"\n        }\n      });\n      GameLobbies.update({\n        gameId\n      }, {\n        $set: {\n          status: \"custom\",\n          endReason: \"finished_early\"\n        }\n      });\n    }\n  }\n\n});\nconst earlyExitPlayerLobby = new ValidatedMethod({\n  name: \"Players.methods.admin.earlyExitPlayerLobby\",\n  validate: new SimpleSchema({\n    exitReason: {\n      label: \"Reason for Exit\",\n      type: String,\n      regEx: /[a-zA-Z0-9_]+/\n    },\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    gameLobbyId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run(_ref7) {\n    let {\n      exitReason,\n      playerId,\n      gameLobbyId\n    } = _ref7;\n\n    if (!Meteor.isServer) {\n      return;\n    }\n\n    const gameLobby = GameLobbies.findOne(gameLobbyId);\n\n    if (!gameLobby) {\n      throw new Error(\"gameLobby not found\");\n    }\n\n    const currentPlayer = Players.findOne(playerId);\n\n    if (currentPlayer && currentPlayer.exitAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nplayer already exited!\");\n      }\n\n      return;\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitAt: new Date(),\n        exitStatus: \"custom\",\n        exitReason\n      }\n    });\n  }\n\n});\nconst retireSinglePlayer = new ValidatedMethod({\n  name: \"Players.methods.admin.retireSingle\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run(_ref8) {\n    let {\n      playerId\n    } = _ref8;\n\n    if (!playerId) {\n      throw new Error(\"empty playerId\");\n    }\n\n    if (!this.userId) {\n      throw new Error(\"unauthorized\");\n    }\n\n    const player = Players.findOne({\n      _id: playerId,\n      retiredAt: {\n        $exists: false\n      }\n    });\n\n    if (!player) {\n      throw new Error(\"Player not found\");\n    }\n\n    const timestamp = new Date().toISOString();\n    Players.update(playerId, {\n      $set: {\n        id: \"\".concat(player.id, \" (Retired custom at \").concat(timestamp, \")\"),\n        retiredAt: new Date(),\n        retiredReason: \"custom\"\n      }\n    });\n    return player;\n  }\n\n});\nconst retireGameFullPlayers = new ValidatedMethod({\n  name: \"Players.methods.admin.retireGameFull\",\n  validate: new SimpleSchema({\n    retiredReason: {\n      label: \"Retired Reason\",\n      type: String,\n      optional: true,\n      allowedValues: exitStatuses\n    }\n  }).validator(),\n\n  run(_ref9) {\n    let {\n      retiredReason\n    } = _ref9;\n\n    if (!this.userId) {\n      throw new Error(\"unauthorized\");\n    }\n\n    const players = Players.find({\n      exitStatus: retiredReason,\n      retiredAt: {\n        $exists: false\n      }\n    }).fetch();\n    const timestamp = new Date().toISOString();\n\n    for (let i = 0; i < players.length; i++) {\n      const player = players[i];\n      Players.update(player._id, {\n        $set: {\n          id: \"\".concat(player.id, \" (Retired \").concat(retiredReason, \" at \").concat(timestamp, \")\"),\n          retiredAt: new Date(),\n          retiredReason\n        }\n      });\n    }\n\n    return players.length;\n  }\n\n});\nconst playerWasRetired = new ValidatedMethod({\n  name: \"Players.methods.playerWasRetired\",\n  validate: IdSchema.validator(),\n\n  run(_ref10) {\n    let {\n      _id\n    } = _ref10;\n    return Boolean(Players.findOne({\n      _id,\n      exitStatus: {\n        $exists: true\n      },\n      retiredAt: {\n        $exists: true\n      }\n    }));\n  }\n\n});\nconst updatePlayerStatus = new ValidatedMethod({\n  name: \"Players.methods.updateStatus\",\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    idle: {\n      type: Boolean\n    },\n    lastActivityAt: {\n      type: Date\n    }\n  }).validator(),\n\n  run(_ref11) {\n    let {\n      playerId,\n      idle,\n      lastActivityAt\n    } = _ref11;\n\n    if (Meteor.isServer) {\n      const playerIdConn = shared.playerIdForConn(this.connection);\n\n      if (!playerIdConn) {\n        return;\n      }\n\n      if (playerId !== playerIdConn) {\n        console.error(\"Attempting to update player status from wrong connection\");\n        return;\n      }\n    }\n\n    Players.update(playerId, {\n      $set: {\n        idle,\n        lastActivityAt\n      }\n    });\n  }\n\n});","map":{"version":3,"sources":["packages/empirica:core/api/players/methods.js"],"names":["module","export","createPlayer","playerReady","updatePlayerData","markPlayerExitStepDone","extendPlayerTimeoutWait","endPlayerTimeoutWait","earlyExitPlayer","earlyExitPlayerLobby","retireSinglePlayer","retireGameFullPlayers","playerWasRetired","updatePlayerStatus","ValidatedMethod","link","v","SimpleSchema","default","Batches","GameLobbies","IdSchema","LobbyConfigs","Games","Players","exitStatuses","sleep","weightedRandom","shared","gameLobbyLock","name","validate","id","type","String","urlParams","Object","blackbox","defaultValue","validator","run","player","batch","findOne","status","full","sort","runningAt","existing","gameLobbyId","_id","insert","filter","lobbies","find","batchId","timedOutAt","$exists","gameId","fetch","length","lobbyPool","l","availableCount","queuedPlayerIds","weigthedLobbyPool","map","lobby","value","weight","update","$addToSet","$set","skipInstructions","debugMode","readyAt","Date","playerIds","Meteor","isServer","assignToLobby","error","console","includes","exitAt","exitStatus","lobbyUpdated","lobbyConfig","lobbyConfigId","timeoutType","timeoutStartedAt","timeoutWaitCount","playerId","regEx","RegEx","Id","key","append","Boolean","optional","noCallback","Error","val","JSON","parse","modifier","$push","autoConvert","trimStrings","removeEmptyStrings","callOnChange","prevValue","data","stepName","exitStepsDone","$inc","$pull","exitReason","label","game","finishedAt","isDevelopment","log","currentPlayer","players","onlinePlayers","endReason","gameLobby","userId","retiredAt","timestamp","toISOString","retiredReason","allowedValues","i","idle","lastActivityAt","playerIdConn","playerIdForConn","connection"],"mappings":"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","sourcesContent":["import { ValidatedMethod } from \"meteor/mdg:validated-method\";\nimport SimpleSchema from \"simpl-schema\";\n\nimport { Batches } from \"../batches/batches.js\";\nimport { GameLobbies } from \"../game-lobbies/game-lobbies\";\nimport { IdSchema } from \"../default-schemas.js\";\nimport { LobbyConfigs } from \"../lobby-configs/lobby-configs.js\";\nimport { Games } from \"../games/games.js\";\nimport { Players } from \"./players\";\nimport { exitStatuses } from \"./players.js\";\nimport { sleep, weightedRandom } from \"../../lib/utils.js\";\nimport shared from \"../../shared.js\";\nimport gameLobbyLock from \"../../gameLobby-lock.js\";\n\nexport const createPlayer = new ValidatedMethod({\n  name: \"Players.methods.create\",\n\n  validate: new SimpleSchema({\n    id: {\n      type: String\n    },\n    urlParams: {\n      type: Object,\n      blackbox: true,\n      defaultValue: {}\n    }\n  }).validator(),\n\n  run(player) {\n    // Find the first running batch (in order of running started time)\n    const batch = Batches.findOne(\n      { status: \"running\", full: false },\n      { sort: { runningAt: 1 } }\n    );\n\n    if (!batch) {\n      // The UI should update and realize there is no batch available\n      // This should be a rare case where a fraction of a second of\n      // desynchornisation when the last available batch just finished.\n      // If this is the case, since the user exist in the DB at this point\n      // but has no lobby assigned, and the UI will soon determine there\n      // is no available game, the UI will switch to \"No experiments\n      // available\", nothing else to do.\n      return;\n    }\n\n    // TODO: MAYBE, add verification that the user is not current connected\n    // elsewhere and this is not a flagrant impersonation. Note that is\n    // extremely difficult to guaranty. Could also add verification of user's\n    // id with email verication for example. For now the assumption is that\n    // there is no immediate reason or long-term motiviation for people to hack\n    // each other's player account.\n\n    const existing = Players.findOne({ id: player.id });\n\n    // If the player already has a game lobby assigned, no need to\n    // re-initialize them\n    if (existing && existing.gameLobbyId) {\n      return existing._id;\n    }\n\n    if (existing) {\n      player = existing;\n    } else {\n      // Because of a bug in SimpleSchema around blackbox: true, skipping\n      // validation here. Validation did happen at the method level though.\n      player._id = Players.insert(player, {\n        filter: false,\n        validate: false\n      });\n    }\n\n    // Looking for all lobbies for batch (for which that game has not started yet)\n    const lobbies = GameLobbies.find({\n      batchId: batch._id,\n      status: \"running\",\n      timedOutAt: { $exists: false },\n      gameId: { $exists: false }\n    }).fetch();\n\n    if (lobbies.length === 0) {\n      // This is the same case as when there are no batches available.\n      return;\n    }\n\n    // Let's first try to find lobbies for which their queue isn't full yet\n    let lobbyPool = lobbies.filter(\n      l => l.availableCount > l.queuedPlayerIds.length\n    );\n\n    // If no lobbies still have \"availability\", just fill any lobby\n    if (lobbyPool.length === 0) {\n      lobbyPool = lobbies;\n    }\n\n    // Book proportially to total expected playerCount\n    const weigthedLobbyPool = lobbyPool.map(lobby => {\n      return {\n        value: lobby,\n        weight: lobby.availableCount\n      };\n    });\n\n    // Choose a lobby in the available weigthed pool\n    const lobby = weightedRandom(weigthedLobbyPool)();\n\n    // Adding the player to specified lobby queue\n    GameLobbies.update(lobby._id, {\n      $addToSet: {\n        queuedPlayerIds: player._id\n      }\n    });\n\n    const gameLobbyId = lobby._id;\n    const $set = { gameLobbyId };\n\n    // Check if there will be instructions\n    let skipInstructions = lobby.debugMode;\n\n    // If there are no instruction, mark the player as ready immediately\n    if (skipInstructions) {\n      $set.readyAt = new Date();\n    }\n\n    Players.update(player._id, { $set });\n\n    // If there are no instruction, player is ready, notify the lobby\n    if (skipInstructions) {\n      GameLobbies.update(gameLobbyId, {\n        $addToSet: { playerIds: player._id }\n      });\n    }\n\n    return player._id;\n  }\n});\n\nexport const playerReady = new ValidatedMethod({\n  name: \"Players.methods.ready\",\n\n  validate: IdSchema.validator(),\n\n  async run({ _id }) {\n    if (!Meteor.isServer) {\n      return;\n    }\n\n    try {\n      // Lobby might be locked if game is currently being created.\n      // We retry until lobby is unlocked.\n      while (!assignToLobby(_id)) {\n        await sleep(1000);\n      }\n    } catch (error) {\n      console.error(\"Players.methods.ready\", error);\n    }\n  }\n});\n\nfunction assignToLobby(_id) {\n  const player = Players.findOne(_id);\n\n  if (!player) {\n    throw `unknown ready player: ${_id}`;\n  }\n  const { readyAt, gameLobbyId } = player;\n\n  if (readyAt) {\n    // Already ready\n    return true;\n  }\n\n  const lobby = GameLobbies.findOne(gameLobbyId);\n\n  if (!lobby) {\n    throw `unknown lobby for ready player: ${_id}`;\n  }\n\n  // GameLobby is locked.\n  if (gameLobbyLock[gameLobbyId]) {\n    return false;\n  }\n\n  // Game is Full, bail the player\n  if (lobby.playerIds.length === lobby.availableCount) {\n    // User already ready, something happened out of order\n    if (lobby.playerIds.includes(_id)) {\n      return true;\n    }\n\n    // Mark the player's participation attemp as failed if\n    // not already marked exited\n    Players.update(\n      {\n        _id,\n        exitAt: { $exists: false }\n      },\n      {\n        $set: {\n          exitAt: new Date(),\n          exitStatus: \"gameFull\"\n        }\n      }\n    );\n\n    return true;\n  }\n\n  // Try to update the GameLobby with the playerIds we just queried.\n  GameLobbies.update(\n    { _id: gameLobbyId, playerIds: lobby.playerIds },\n    {\n      $addToSet: { playerIds: _id }\n    }\n  );\n\n  // If the playerId insert succeeded (playerId WAS added to playerIds),\n  // mark the user record as ready and potentially start the individual\n  // lobby timer.\n  const lobbyUpdated = GameLobbies.findOne(gameLobbyId);\n  if (lobbyUpdated.playerIds.includes(_id)) {\n    // If it did work, mark player as ready\n    $set = { readyAt: new Date() };\n\n    // If it's an individual lobby timeout, mark the first timer as started.\n    const lobbyConfig = LobbyConfigs.findOne(lobbyUpdated.lobbyConfigId);\n    if (lobbyConfig.timeoutType === \"individual\") {\n      $set.timeoutStartedAt = new Date();\n      $set.timeoutWaitCount = 1;\n    }\n\n    Players.update(_id, { $set });\n    return true;\n  }\n\n  // If the playerId insert failed (playerId NOT added to playerIds), the\n  // playerIds has changed since it was queried and the lobby might not\n  // have any available slots left, loop and retry.\n  return false;\n}\n\nexport const updatePlayerData = new ValidatedMethod({\n  name: \"Players.methods.updateData\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    key: {\n      type: String\n    },\n    value: {\n      type: String\n    },\n    append: {\n      type: Boolean,\n      optional: true\n    },\n    noCallback: {\n      type: Boolean,\n      optional: true\n    }\n  }).validator(),\n\n  run({ playerId, key, value, append, noCallback }) {\n    const player = Players.findOne(playerId);\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n    // TODO check can update this record player\n\n    const val = JSON.parse(value);\n    let update = { [`data.${key}`]: val };\n    const modifier = append ? { $push: update } : { $set: update };\n\n    Players.update(playerId, modifier, {\n      autoConvert: false,\n      filter: false,\n      validate: false,\n      trimStrings: false,\n      removeEmptyStrings: false\n    });\n\n    if (Meteor.isServer && !noCallback) {\n      shared.callOnChange({\n        playerId,\n        player,\n        key,\n        value: val,\n        prevValue: player.data && player.data[key],\n        append\n      });\n    }\n  }\n});\n\nexport const markPlayerExitStepDone = new ValidatedMethod({\n  name: \"Players.methods.markExitStepDone\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    stepName: {\n      type: String\n    }\n  }).validator(),\n\n  run({ playerId, stepName }) {\n    const player = Players.findOne(playerId);\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n    // TODO check can update this record player\n\n    Players.update(playerId, { $addToSet: { exitStepsDone: stepName } });\n  }\n});\n\nexport const extendPlayerTimeoutWait = new ValidatedMethod({\n  name: \"Players.methods.extendTimeoutWait\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run({ playerId }) {\n    const player = Players.findOne(playerId);\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n\n    Players.update(playerId, {\n      $inc: { timeoutWaitCount: 1 },\n      $set: { timeoutStartedAt: new Date() }\n    });\n  }\n});\n\nexport const endPlayerTimeoutWait = new ValidatedMethod({\n  name: \"Players.methods.endTimeoutWait\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run({ playerId }) {\n    const player = Players.findOne(playerId);\n    if (!player) {\n      throw new Error(\"player not found\");\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitStatus: \"playerEndedLobbyWait\",\n        exitAt: new Date()\n      }\n    });\n    GameLobbies.update(player.gameLobbyId, {\n      $pull: {\n        playerIds: playerId\n        // We keep the player in queuedPlayerIds so they will still have the\n        // fact they were in a lobby available in the UI, and so we can show\n        // them the exit steps.\n      }\n    });\n  }\n});\n\nexport const earlyExitPlayer = new ValidatedMethod({\n  name: \"Players.methods.admin.earlyExitPlayer\",\n\n  validate: new SimpleSchema({\n    exitReason: {\n      label: \"Reason for Exit\",\n      type: String,\n      regEx: /[a-zA-Z0-9_]+/\n    },\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    gameId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run({ exitReason, playerId, gameId }) {\n    if (!Meteor.isServer) {\n      return;\n    }\n\n    const game = Games.findOne(gameId);\n\n    if (!game) {\n      throw new Error(\"game not found\");\n    }\n\n    if (game && game.finishedAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\n\\ngame already ended!\");\n      }\n\n      return;\n    }\n\n    const currentPlayer = Players.findOne(playerId);\n\n    if (currentPlayer && currentPlayer.exitAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nplayer already exited!\");\n      }\n\n      return;\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitAt: new Date(),\n        exitStatus: \"custom\",\n        exitReason\n      }\n    });\n\n    const players = Players.find({ gameId }).fetch();\n    const onlinePlayers = players.filter(player => !player.exitAt);\n\n    if (!onlinePlayers || (onlinePlayers && onlinePlayers.length === 0)) {\n      Games.update(gameId, {\n        $set: {\n          finishedAt: new Date(),\n          status: \"custom\",\n          endReason: \"finished_early\"\n        }\n      });\n\n      GameLobbies.update(\n        { gameId },\n        {\n          $set: {\n            status: \"custom\",\n            endReason: \"finished_early\"\n          }\n        }\n      );\n    }\n  }\n});\n\nexport const earlyExitPlayerLobby = new ValidatedMethod({\n  name: \"Players.methods.admin.earlyExitPlayerLobby\",\n\n  validate: new SimpleSchema({\n    exitReason: {\n      label: \"Reason for Exit\",\n      type: String,\n      regEx: /[a-zA-Z0-9_]+/\n    },\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n    gameLobbyId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run({ exitReason, playerId, gameLobbyId }) {\n    if (!Meteor.isServer) {\n      return;\n    }\n\n    const gameLobby = GameLobbies.findOne(gameLobbyId);\n\n    if (!gameLobby) {\n      throw new Error(\"gameLobby not found\");\n    }\n\n    const currentPlayer = Players.findOne(playerId);\n\n    if (currentPlayer && currentPlayer.exitAt) {\n      if (Meteor.isDevelopment) {\n        console.log(\"\\nplayer already exited!\");\n      }\n\n      return;\n    }\n\n    Players.update(playerId, {\n      $set: {\n        exitAt: new Date(),\n        exitStatus: \"custom\",\n        exitReason\n      }\n    });\n  }\n});\n\nexport const retireSinglePlayer = new ValidatedMethod({\n  name: \"Players.methods.admin.retireSingle\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    }\n  }).validator(),\n\n  run({ playerId }) {\n    if (!playerId) {\n      throw new Error(\"empty playerId\");\n    }\n\n    if (!this.userId) {\n      throw new Error(\"unauthorized\");\n    }\n\n    const player = Players.findOne({\n      _id: playerId,\n      retiredAt: { $exists: false }\n    });\n\n    if (!player) {\n      throw new Error(\"Player not found\");\n    }\n\n    const timestamp = new Date().toISOString();\n\n    Players.update(playerId, {\n      $set: {\n        id: `${player.id} (Retired custom at ${timestamp})`,\n        retiredAt: new Date(),\n        retiredReason: \"custom\"\n      }\n    });\n\n    return player;\n  }\n});\n\nexport const retireGameFullPlayers = new ValidatedMethod({\n  name: \"Players.methods.admin.retireGameFull\",\n\n  validate: new SimpleSchema({\n    retiredReason: {\n      label: \"Retired Reason\",\n      type: String,\n      optional: true,\n      allowedValues: exitStatuses\n    }\n  }).validator(),\n\n  run({ retiredReason }) {\n    if (!this.userId) {\n      throw new Error(\"unauthorized\");\n    }\n\n    const players = Players.find({\n      exitStatus: retiredReason,\n      retiredAt: { $exists: false }\n    }).fetch();\n\n    const timestamp = new Date().toISOString();\n\n    for (let i = 0; i < players.length; i++) {\n      const player = players[i];\n\n      Players.update(player._id, {\n        $set: {\n          id: `${player.id} (Retired ${retiredReason} at ${timestamp})`,\n          retiredAt: new Date(),\n          retiredReason\n        }\n      });\n    }\n\n    return players.length;\n  }\n});\n\nexport const playerWasRetired = new ValidatedMethod({\n  name: \"Players.methods.playerWasRetired\",\n\n  validate: IdSchema.validator(),\n\n  run({ _id }) {\n    return Boolean(\n      Players.findOne({\n        _id,\n        exitStatus: { $exists: true },\n        retiredAt: { $exists: true }\n      })\n    );\n  }\n});\n\nexport const updatePlayerStatus = new ValidatedMethod({\n  name: \"Players.methods.updateStatus\",\n\n  validate: new SimpleSchema({\n    playerId: {\n      type: String,\n      regEx: SimpleSchema.RegEx.Id\n    },\n\n    idle: {\n      type: Boolean\n    },\n\n    lastActivityAt: {\n      type: Date\n    }\n  }).validator(),\n\n  run({ playerId, idle, lastActivityAt }) {\n    if (Meteor.isServer) {\n      const playerIdConn = shared.playerIdForConn(this.connection);\n      if (!playerIdConn) {\n        return;\n      }\n      if (playerId !== playerIdConn) {\n        console.error(\n          \"Attempting to update player status from wrong connection\"\n        );\n        return;\n      }\n    }\n\n    Players.update(playerId, {\n      $set: {\n        idle,\n        lastActivityAt\n      }\n    });\n  }\n});\n"]},"sourceType":"module","hash":"6edf3c47f37e6616dff630b2d7dd548b773a8d05"}
