{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/treatments/treatments.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/empirica:core/api/treatments/treatments.js","filename":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/treatments/treatments.js","passPerPreset":false,"envName":"development","cwd":"/Users/tilenbabnik/Desktop/pgg","root":"/Users/tilenbabnik/Desktop/pgg","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.9.2","helpers":true,"useESModules":false,"corejs":false}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/tilenbabnik/Desktop/pgg/packages/empirica:core/api/treatments/treatments.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/empirica:core/api/treatments/treatments.js"}},"code":"module.export({\n  Treatments: () => Treatments\n});\nlet SimpleSchema;\nmodule.link(\"simpl-schema\", {\n  default(v) {\n    SimpleSchema = v;\n  }\n\n}, 0);\nlet Factors;\nmodule.link(\"../factors/factors.js\", {\n  Factors(v) {\n    Factors = v;\n  }\n\n}, 1);\nlet FactorTypes;\nmodule.link(\"../factor-types/factor-types.js\", {\n  FactorTypes(v) {\n    FactorTypes = v;\n  }\n\n}, 2);\nlet TimestampSchema, ArchivedSchema;\nmodule.link(\"../default-schemas\", {\n  TimestampSchema(v) {\n    TimestampSchema = v;\n  },\n\n  ArchivedSchema(v) {\n    ArchivedSchema = v;\n  }\n\n}, 3);\nconst Treatments = new Mongo.Collection(\"treatments\");\nTreatments.helpers({\n  displayName() {\n    return this.name || _.map(this.factors(), c => c.fullLabel()).join(\" - \");\n  },\n\n  factor(name) {\n    const type = FactorTypes.findOne({\n      name\n    });\n\n    if (!type) {\n      return;\n    }\n\n    return this.factors().find(c => c.factorTypeId === type._id);\n  },\n\n  factors() {\n    const query = {\n      _id: {\n        $in: this.factorIds\n      }\n    };\n    return Factors.find(query).fetch();\n  },\n\n  factorsObject() {\n    const doc = {};\n    this.factors().forEach(c => {\n      const type = FactorTypes.findOne(c.factorTypeId);\n      doc[type.name] = c.value;\n    });\n    return doc;\n  }\n\n});\nTreatments.schema = new SimpleSchema({\n  // Optional experimenter given name for the treatment\n  name: {\n    type: String,\n    max: 256,\n    optional: true,\n\n    custom() {\n      if (this.isSet && Treatments.find({\n        name: this.value\n      }).count() > 0) {\n        return \"notUnique\";\n      }\n    } // regEx: /^[a-zA-Z0-9_]+$/\n\n\n  },\n  // Array of factorIds\n  factorIds: {\n    type: Array,\n    minCount: FactorTypes.requiredTypes,\n    label: \"Factors\",\n    index: true,\n    denyUpdate: true // // Custom validation verifies required factors are present and that\n    // // there are no duplicate factors with the same key. We cannot easily\n    // // verify one of each factors is present.\n    // custom() {\n    //   if (!Meteor.isServer || !this.isInsert) {\n    //     return;\n    //   }\n    //   const factors = Factors.find({ _id: { $in: this.value } }).fetch();\n    //   const doc = {};\n    //   factors.forEach(c => (doc[c.type] = c.value));\n    //   const context = factorsSchema.newContext();\n    //   context.validate(doc);\n    //   if (!context.isValid()) {\n    //     const error = {\n    //       name: \"factorIds\",\n    //       type: \"invalid\",\n    //       details: context.validationErrors()\n    //     };\n    //     this.addValidationErrors([error]);\n    //     return \"invalid\";\n    //   }\n    // }\n\n  },\n  \"factorIds.$\": {\n    type: String,\n    regEx: SimpleSchema.RegEx.Id,\n    label: \"Factor Item\"\n  }\n});\nTreatments.schema.addDocValidator((_ref) => {\n  let {\n    factorIds\n  } = _ref;\n\n  if (!this.isInsert) {\n    return [];\n  }\n\n  const query = {\n    factorIds: {\n      $size: factorIds.length,\n      $all: factorIds\n    }\n  };\n\n  if (Boolean(Treatments.findOne(query))) {\n    return [{\n      name: \"factorIds\",\n      type: \"notUnique\"\n    }];\n  }\n\n  return [];\n});\nTreatments.schema.extend(TimestampSchema);\nTreatments.schema.extend(ArchivedSchema);\nTreatments.attachSchema(Treatments.schema);","map":{"version":3,"sources":["packages/empirica:core/api/treatments/treatments.js"],"names":["module","export","Treatments","SimpleSchema","link","default","v","Factors","FactorTypes","TimestampSchema","ArchivedSchema","Mongo","Collection","helpers","displayName","name","_","map","factors","c","fullLabel","join","factor","type","findOne","find","factorTypeId","_id","query","$in","factorIds","fetch","factorsObject","doc","forEach","value","schema","String","max","optional","custom","isSet","count","Array","minCount","requiredTypes","label","index","denyUpdate","regEx","RegEx","Id","addDocValidator","isInsert","$size","length","$all","Boolean","extend","attachSchema"],"mappings":"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","sourcesContent":["import SimpleSchema from \"simpl-schema\";\n\nimport { Factors } from \"../factors/factors.js\";\nimport { FactorTypes } from \"../factor-types/factor-types.js\";\nimport { TimestampSchema, ArchivedSchema } from \"../default-schemas\";\n\nexport const Treatments = new Mongo.Collection(\"treatments\");\n\nTreatments.helpers({\n  displayName() {\n    return this.name || _.map(this.factors(), c => c.fullLabel()).join(\" - \");\n  },\n\n  factor(name) {\n    const type = FactorTypes.findOne({ name });\n    if (!type) {\n      return;\n    }\n    return this.factors().find(c => c.factorTypeId === type._id);\n  },\n\n  factors() {\n    const query = { _id: { $in: this.factorIds } };\n    return Factors.find(query).fetch();\n  },\n\n  factorsObject() {\n    const doc = {};\n    this.factors().forEach(c => {\n      const type = FactorTypes.findOne(c.factorTypeId);\n      doc[type.name] = c.value;\n    });\n    return doc;\n  }\n});\n\nTreatments.schema = new SimpleSchema({\n  // Optional experimenter given name for the treatment\n  name: {\n    type: String,\n    max: 256,\n    optional: true,\n    custom() {\n      if (this.isSet && Treatments.find({ name: this.value }).count() > 0) {\n        return \"notUnique\";\n      }\n    }\n\n    // regEx: /^[a-zA-Z0-9_]+$/\n  },\n\n  // Array of factorIds\n  factorIds: {\n    type: Array,\n    minCount: FactorTypes.requiredTypes,\n    label: \"Factors\",\n    index: true,\n    denyUpdate: true\n    // // Custom validation verifies required factors are present and that\n    // // there are no duplicate factors with the same key. We cannot easily\n    // // verify one of each factors is present.\n    // custom() {\n    //   if (!Meteor.isServer || !this.isInsert) {\n    //     return;\n    //   }\n\n    //   const factors = Factors.find({ _id: { $in: this.value } }).fetch();\n    //   const doc = {};\n    //   factors.forEach(c => (doc[c.type] = c.value));\n\n    //   const context = factorsSchema.newContext();\n    //   context.validate(doc);\n    //   if (!context.isValid()) {\n    //     const error = {\n    //       name: \"factorIds\",\n    //       type: \"invalid\",\n    //       details: context.validationErrors()\n    //     };\n    //     this.addValidationErrors([error]);\n    //     return \"invalid\";\n    //   }\n    // }\n  },\n\n  \"factorIds.$\": {\n    type: String,\n    regEx: SimpleSchema.RegEx.Id,\n    label: `Factor Item`\n  }\n});\n\nTreatments.schema.addDocValidator(({ factorIds }) => {\n  if (!this.isInsert) {\n    return [];\n  }\n  const query = {\n    factorIds: {\n      $size: factorIds.length,\n      $all: factorIds\n    }\n  };\n  if (Boolean(Treatments.findOne(query))) {\n    return [\n      {\n        name: \"factorIds\",\n        type: \"notUnique\"\n      }\n    ];\n  }\n  return [];\n});\n\nTreatments.schema.extend(TimestampSchema);\nTreatments.schema.extend(ArchivedSchema);\nTreatments.attachSchema(Treatments.schema);\n"]},"sourceType":"module","hash":"8f12b28a6a70b436134d5aff19084436ccca946d"}
