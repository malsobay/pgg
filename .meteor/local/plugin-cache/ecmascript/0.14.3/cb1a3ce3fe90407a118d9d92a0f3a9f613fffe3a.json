{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/mosobay/Dropbox (MIT)/research/pgg/pgg_empirica/packages/empirica:core/api/games/create.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/empirica:core/api/games/create.js","filename":"/Users/mosobay/Dropbox (MIT)/research/pgg/pgg_empirica/packages/empirica:core/api/games/create.js","passPerPreset":false,"envName":"production","cwd":"/Users/mosobay/Dropbox (MIT)/research/pgg/pgg_empirica","root":"/Users/mosobay/Dropbox (MIT)/research/pgg/pgg_empirica","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.9.2","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/mosobay/Dropbox (MIT)/research/pgg/pgg_empirica/packages/empirica:core/api/games/create.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/empirica:core/api/games/create.js"}},"code":"let _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 0);\nmodule.export({\n  createGameFromLobby: () => createGameFromLobby,\n  sendPlayersToNextBatches: () => sendPlayersToNextBatches\n});\nlet moment;\nmodule.link(\"moment\", {\n  default(v) {\n    moment = v;\n  }\n\n}, 0);\nlet Batches;\nmodule.link(\"../batches/batches.js\", {\n  Batches(v) {\n    Batches = v;\n  }\n\n}, 1);\nlet GameLobbies;\nmodule.link(\"../game-lobbies/game-lobbies.js\", {\n  GameLobbies(v) {\n    GameLobbies = v;\n  }\n\n}, 2);\nlet Games;\nmodule.link(\"./games\", {\n  Games(v) {\n    Games = v;\n  }\n\n}, 3);\nlet PlayerRounds;\nmodule.link(\"../player-rounds/player-rounds\", {\n  PlayerRounds(v) {\n    PlayerRounds = v;\n  }\n\n}, 4);\nlet PlayerStages;\nmodule.link(\"../player-stages/player-stages\", {\n  PlayerStages(v) {\n    PlayerStages = v;\n  }\n\n}, 5);\nlet Players;\nmodule.link(\"../players/players\", {\n  Players(v) {\n    Players = v;\n  }\n\n}, 6);\nlet Rounds;\nmodule.link(\"../rounds/rounds\", {\n  Rounds(v) {\n    Rounds = v;\n  }\n\n}, 7);\nlet Stages;\nmodule.link(\"../stages/stages\", {\n  Stages(v) {\n    Stages = v;\n  }\n\n}, 8);\nlet earlyExitGameLobby;\nmodule.link(\"../game-lobbies/methods\", {\n  earlyExitGameLobby(v) {\n    earlyExitGameLobby = v;\n  }\n\n}, 9);\nlet augmentPlayerStageRound, augmentGameStageRound;\nmodule.link(\"../player-stages/augment.js\", {\n  augmentPlayerStageRound(v) {\n    augmentPlayerStageRound = v;\n  },\n\n  augmentGameStageRound(v) {\n    augmentGameStageRound = v;\n  }\n\n}, 10);\nlet augmentGameObject;\nmodule.link(\"../games/augment.js\", {\n  augmentGameObject(v) {\n    augmentGameObject = v;\n  }\n\n}, 11);\nlet config;\nmodule.link(\"../../server\", {\n  config(v) {\n    config = v;\n  }\n\n}, 12);\nlet weightedRandom;\nmodule.link(\"../../lib/utils.js\", {\n  weightedRandom(v) {\n    weightedRandom = v;\n  }\n\n}, 13);\nlet log;\nmodule.link(\"../../lib/log.js\", {\n  default(v) {\n    log = v;\n  }\n\n}, 14);\nlet gameLobbyLock;\nmodule.link(\"../../gameLobby-lock.js\", {\n  default(v) {\n    gameLobbyLock = v;\n  }\n\n}, 15);\nconst addStageErrMsg = \"\\\"round.addStage()\\\" requires an argument object with 3 properties:\\n- name: internal name you'll use to write conditional logic in your experiment.\\n- displayName: the name of the Stage the player will see in the UI.\\n- durationInSeconds: the duration in seconds of the stage\\n\\ne.g.: round.addStage({\\n  name: \\\"response\\\",\\n  displayName: \\\"Response\\\",\\n  durationInSeconds: 120\\n});\\n\\n\";\n\nconst createGameFromLobby = gameLobby => {\n  if (Games.find({\n    gameLobbyId: gameLobby._id\n  }).count() > 0) {\n    return;\n  }\n\n  const players = gameLobby.players();\n  const batch = gameLobby.batch();\n  const treatment = gameLobby.treatment();\n  const factors = treatment.factorsObject();\n  const {\n    batchId,\n    treatmentId,\n    status,\n    debugMode\n  } = gameLobby;\n  players.forEach(player => {\n    player.data = player.data || {};\n\n    player.set = (key, value) => {\n      player.data[key] = value;\n    };\n\n    player.get = key => {\n      return player.data[key];\n    };\n  }); // Ask (experimenter designer) init function to configure this game\n  // given the factors and players given.\n\n  const params = {\n    data: _objectSpread({}, gameLobby.data),\n    rounds: [],\n    players\n  };\n  var gameCollector = {\n    players,\n    treatment: factors,\n\n    get(k) {\n      return params.data[k];\n    },\n\n    set(k, v) {\n      params.data[k] = v;\n    },\n\n    addRound(props) {\n      const data = props ? props.data : {} || {};\n      const round = {\n        data,\n        stages: []\n      };\n      params.rounds.push(round);\n      return {\n        get(k) {\n          return round.data[k];\n        },\n\n        set(k, v) {\n          round.data[k] = v;\n        },\n\n        addStage(_ref) {\n          let {\n            name,\n            displayName,\n            durationInSeconds,\n            data = {}\n          } = _ref;\n\n          try {\n            if (!name || !displayName || !durationInSeconds) {\n              log.error(addStageErrMsg);\n              log.error(\"Got: \".concat(JSON.stringify({\n                name,\n                displayName,\n                durationInSeconds\n              }, null, \"  \")));\n              throw \"gameInit error\";\n            }\n\n            const durationInSecondsAsInt = parseInt(durationInSeconds);\n\n            if (Number.isNaN(durationInSecondsAsInt) || durationInSecondsAsInt < 1) {\n              console.error(\"Error in addStage call: durationInSeconds must be an number > 0 (name: \".concat(name, \")\"));\n            }\n\n            const stage = {\n              name,\n              displayName,\n              durationInSeconds: durationInSecondsAsInt\n            };\n            round.stages.push(_objectSpread({}, stage, {\n              data\n            }));\n            return _objectSpread({}, stage, {\n              get(k) {\n                return data[k];\n              },\n\n              set(k, v) {\n                data[k] = v;\n              }\n\n            });\n          } catch (error) {\n            earlyExitGameLobby.call({\n              exitReason: \"initError\",\n              gameLobbyId: gameLobby._id\n            });\n          }\n        }\n\n      };\n    }\n\n  };\n\n  try {\n    gameLobbyLock[gameLobby._id] = true;\n    config.gameInit(gameCollector, factors);\n  } catch (err) {\n    console.error(\"fatal error encounter calling Empirica.gameInit:\");\n    console.error(err);\n    earlyExitGameLobby.call({\n      exitReason: \"gameError\",\n      gameLobbyId: gameLobby._id\n    });\n    return;\n  }\n\n  if (!params.rounds || params.rounds.length === 0) {\n    throw \"at least one round must be added per game\";\n  }\n\n  params.rounds.forEach(round => {\n    if (!round.stages || round.stages.length === 0) {\n      throw \"at least one stage must be added per round\";\n    }\n\n    round.stages.forEach((_ref2) => {\n      let {\n        name,\n        displayName,\n        durationInSeconds\n      } = _ref2;\n\n      // This should never happen as we already verified it above.\n      if (!name || !displayName || !durationInSeconds) {\n        log.error(addStageErrMsg);\n        throw \"invalid stage\";\n      }\n    });\n  }); // Keep debug mode from lobby\n\n  params.debugMode = debugMode; // We need to create/configure stuff associated with the game before we\n  // create it so we generate the id early\n\n  const gameId = gameLobby._id;\n  params._id = gameId;\n  params.gameLobbyId = gameLobby._id; // We also add a few related objects\n\n  params.treatmentId = treatmentId;\n  params.batchId = batchId;\n  params.status = status; // playerIds is the reference to players stored in the game object\n\n  params.playerIds = _.pluck(params.players, \"_id\"); // We then need to verify all these ids exist and are unique, the\n  // init function might not have returned them correctly\n\n  const len = _.uniq(_.compact(params.playerIds)).length;\n\n  if (len !== params.players.length || len !== players.length) {\n    throw new Error(\"invalid player count\");\n  } // We want to copy over the changes made by the init function and save the\n  // gameId in the player objects already in the DB\n\n\n  params.players.forEach((_ref3) => {\n    let {\n      _id,\n      data\n    } = _ref3;\n    Players.update(_id, {\n      $set: {\n        gameId,\n        data\n      }\n    }, {\n      autoConvert: false,\n      filter: false,\n      validate: false,\n      trimStrings: false,\n      removeEmptyStrings: false\n    });\n  }); // Create the round objects\n\n  let stageIndex = 0;\n  let totalDuration = 0;\n  let firstRoundId;\n  const insertOption = {\n    autoConvert: false,\n    filter: false,\n    validate: false,\n    trimStrings: false,\n    removeEmptyStrings: false\n  };\n  let StagesUpdateOp = Stages.rawCollection().initializeUnorderedBulkOp();\n  let RoundsOp = Rounds.rawCollection().initializeUnorderedBulkOp();\n  let StagesOp = Stages.rawCollection().initializeUnorderedBulkOp();\n  let roundsOpResult;\n  let stagesOpResult;\n  params.rounds.forEach((round, index) => RoundsOp.insert(_.extend({\n    gameId,\n    index,\n    _id: Random.id(),\n    createdAt: new Date(),\n    data: {}\n  }, round), insertOption));\n  roundsOpResult = Meteor.wrapAsync(RoundsOp.execute, RoundsOp)();\n  const roundIds = roundsOpResult.getInsertedIds().map(ids => ids._id);\n  params.roundIds = roundIds;\n  RoundsOp = Rounds.rawCollection().initializeUnorderedBulkOp();\n  params.rounds.forEach((round, index) => {\n    const roundId = roundIds[index];\n    const {\n      players\n    } = params;\n    StagesOp = Stages.rawCollection().initializeUnorderedBulkOp();\n    let PlayerStagesOp = PlayerStages.rawCollection().initializeUnorderedBulkOp();\n    let PlayerRoundsOp = PlayerRounds.rawCollection().initializeUnorderedBulkOp();\n    round.stages.forEach(stage => {\n      if (batch.debugMode) {\n        stage.durationInSeconds = 60 * 60; // Stage time in debugMode is 1h\n      }\n\n      totalDuration += stage.durationInSeconds;\n\n      const sParams = _.extend({\n        gameId,\n        roundId,\n        index: stageIndex,\n        _id: Random.id(),\n        createdAt: new Date(),\n        data: {}\n      }, stage);\n\n      StagesOp.insert(sParams, insertOption);\n      stageIndex++;\n    });\n    stagesOpResult = Meteor.wrapAsync(StagesOp.execute, StagesOp)();\n    const stageIds = stagesOpResult.getInsertedIds().map(ids => ids._id);\n    stageIds.forEach(stageId => {\n      if (!params.currentStageId) {\n        firstRoundId = roundId;\n        params.currentStageId = stageId;\n      }\n\n      players.forEach((_ref4) => {\n        let {\n          _id: playerId\n        } = _ref4;\n        return PlayerStagesOp.insert({\n          playerId,\n          stageId,\n          roundId,\n          gameId,\n          batchId,\n          _id: Random.id(),\n          createdAt: new Date(),\n          data: {}\n        });\n      });\n    });\n    const playerStagesResult = Meteor.wrapAsync(PlayerStagesOp.execute, PlayerStagesOp)();\n    const playerStageIds = playerStagesResult.getInsertedIds().map(ids => ids._id);\n    stageIds.forEach(stageId => StagesUpdateOp.find({\n      _id: stageId\n    }).upsert().updateOne({\n      $set: {\n        playerStageIds,\n        updatedAt: new Date()\n      }\n    }));\n    players.forEach((_ref5) => {\n      let {\n        _id: playerId\n      } = _ref5;\n      return PlayerRoundsOp.insert({\n        playerId,\n        roundId,\n        gameId,\n        batchId,\n        _id: Random.id(),\n        data: {},\n        createdAt: new Date()\n      });\n    });\n    const playerRoundIdsResult = Meteor.wrapAsync(PlayerRoundsOp.execute, PlayerRoundsOp)();\n    const playerRoundIds = playerRoundIdsResult.getInsertedIds().map(ids => ids._id);\n    RoundsOp.find({\n      _id: roundId\n    }).upsert().updateOne({\n      $set: {\n        stageIds,\n        playerRoundIds,\n        updatedAt: new Date()\n      }\n    });\n  });\n  Meteor.wrapAsync(StagesUpdateOp.execute, StagesUpdateOp)();\n  Meteor.wrapAsync(RoundsOp.execute, RoundsOp)(); // An estimation of the finish time to help querying.\n  // At the moment, this will 100% break with pausing the game/batch.\n\n  params.estFinishedTime = moment() // Give it an extra 24h (86400s) window for the inter-stage sync buffer.\n  // It was 5 min and that failed on an experiment with many rounds.\n  // This value is not extremely useful, it's main purpose is currently\n  // to stop querying games indefinitely in the update game background job.\n  // It was also meant to be an approximate estimate for when the game could\n  // end at the maximum, that we could show in the admin, but it can no longer\n  // work, and it is questionable if the \"stop querying\" \"feature\" is still\n  // adequate.\n  .add(totalDuration + 86400, \"seconds\").toDate(); // We're no longer filtering out unspecified fields on insert because of a\n  // simpleschema bug, so we need to remove invalid params now.\n\n  delete params.players;\n  delete params.rounds; // Insert game. As soon as it comes online, the game will start for the\n  // players so all related object (rounds, stages, players) must be created\n  // and ready\n\n  Games.insert(params, {\n    autoConvert: false,\n    filter: false,\n    validate: false,\n    trimStrings: false,\n    removeEmptyStrings: false\n  }); // Let Game Lobby know Game ID\n\n  GameLobbies.update(gameLobby._id, {\n    $set: {\n      gameId\n    }\n  }); //\n  // Overbooking\n  //\n  // Overbooked players that did not finish the intro and won't be in this game\n\n  const failedPlayerIds = _.difference(gameLobby.queuedPlayerIds, gameLobby.playerIds);\n\n  sendPlayersToNextBatches(failedPlayerIds, batchId, gameLobby); //\n  // Call the callbacks\n  //\n\n  const {\n    onRoundStart,\n    onGameStart,\n    onStageStart\n  } = config;\n\n  if ((onGameStart || onRoundStart || onStageStart) && firstRoundId) {\n    const game = Games.findOne(gameId);\n    augmentGameObject({\n      game,\n      treatment,\n      firstRoundId,\n      currentStageId: params.currentStageId\n    });\n    const nextRound = game.rounds.find(r => r._id === firstRoundId);\n    const nextStage = nextRound.stages.find(s => s._id === params.currentStageId);\n    augmentGameStageRound(game, nextStage, nextRound);\n\n    if (onGameStart) {\n      onGameStart(game);\n    }\n\n    if (onRoundStart) {\n      onRoundStart(game, nextRound);\n    }\n\n    if (onStageStart) {\n      onStageStart(game, nextRound, nextStage);\n    }\n  } //\n  // Start the game\n  //\n\n\n  const startTimeAt = moment().add(Stages.stagePaddingDuration).toDate();\n  Stages.update(params.currentStageId, {\n    $set: {\n      startTimeAt\n    }\n  });\n  delete gameLobbyLock[gameLobby._id];\n};\n\nfunction sendPlayersToNextBatches(playerIds, batchId, gameLobby) {\n  // Find other lobbies that are not full yet with the same treatment\n  const runningBatches = Batches.find({\n    _id: {\n      $ne: batchId\n    },\n    status: \"running\"\n  }, {\n    sort: {\n      runningAt: 1\n    }\n  });\n  const {\n    treatmentId\n  } = gameLobby;\n  const lobbiesGroups = runningBatches.map(() => []);\n  const runningBatcheIds = runningBatches.map(b => b._id);\n  lobbiesGroups.push([]);\n  const possibleLobbies = GameLobbies.find({\n    _id: {\n      $ne: gameLobby._id\n    },\n    status: \"running\",\n    timedOutAt: {\n      $exists: false\n    },\n    gameId: {\n      $exists: false\n    },\n    treatmentId\n  }).fetch();\n  possibleLobbies.forEach(lobby => {\n    if (lobby.batchId === batchId) {\n      lobbiesGroups[0].push(lobby);\n    } else {\n      lobbiesGroups[runningBatcheIds.indexOf(lobby.batchId) + 1].push(lobby);\n    }\n  }); // If no lobbies left, lead players to exit\n\n  if (possibleLobbies.length === 0) {\n    if (playerIds.length > 0) {\n      Players.update({\n        _id: {\n          $in: playerIds\n        }\n      }, {\n        $set: {\n          exitAt: new Date(),\n          exitStatus: \"gameFull\"\n        }\n      }, {\n        multi: true\n      });\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < lobbiesGroups.length; i++) {\n    const lobbies = lobbiesGroups[i];\n\n    if (lobbies.length === 0) {\n      continue;\n    } // If there are lobbies remaining, distribute them across the lobbies\n    // proportinally to the initial playerCount\n\n\n    const weigthedLobbyPool = weightedRandom(lobbies.map(lobby => {\n      return {\n        value: lobby,\n        weight: lobby.availableCount\n      };\n    }));\n\n    for (let i = 0; i < playerIds.length; i++) {\n      const playerId = playerIds[i];\n      const lobby = weigthedLobbyPool(); // Adding the player to specified lobby queue\n\n      const $addToSet = {\n        queuedPlayerIds: playerId\n      };\n\n      if (gameLobby.playerIds.includes(playerId)) {\n        $addToSet.playerIds = playerId;\n      }\n\n      GameLobbies.update(lobby._id, {\n        $addToSet\n      });\n      Players.update(playerId, {\n        $set: {\n          gameLobbyId: lobby._id\n        }\n      });\n    }\n\n    break;\n  }\n}","map":{"version":3,"sources":["packages/empirica:core/api/games/create.js"],"names":["_objectSpread","module","link","default","v","export","createGameFromLobby","sendPlayersToNextBatches","moment","Batches","GameLobbies","Games","PlayerRounds","PlayerStages","Players","Rounds","Stages","earlyExitGameLobby","augmentPlayerStageRound","augmentGameStageRound","augmentGameObject","config","weightedRandom","log","gameLobbyLock","addStageErrMsg","gameLobby","find","gameLobbyId","_id","count","players","batch","treatment","factors","factorsObject","batchId","treatmentId","status","debugMode","forEach","player","data","set","key","value","get","params","rounds","gameCollector","k","addRound","props","round","stages","push","addStage","name","displayName","durationInSeconds","error","JSON","stringify","durationInSecondsAsInt","parseInt","Number","isNaN","console","stage","call","exitReason","gameInit","err","length","gameId","playerIds","_","pluck","len","uniq","compact","Error","update","$set","autoConvert","filter","validate","trimStrings","removeEmptyStrings","stageIndex","totalDuration","firstRoundId","insertOption","StagesUpdateOp","rawCollection","initializeUnorderedBulkOp","RoundsOp","StagesOp","roundsOpResult","stagesOpResult","index","insert","extend","Random","id","createdAt","Date","Meteor","wrapAsync","execute","roundIds","getInsertedIds","map","ids","roundId","PlayerStagesOp","PlayerRoundsOp","sParams","stageIds","stageId","currentStageId","playerId","playerStagesResult","playerStageIds","upsert","updateOne","updatedAt","playerRoundIdsResult","playerRoundIds","estFinishedTime","add","toDate","failedPlayerIds","difference","queuedPlayerIds","onRoundStart","onGameStart","onStageStart","game","findOne","nextRound","r","nextStage","s","startTimeAt","stagePaddingDuration","runningBatches","$ne","sort","runningAt","lobbiesGroups","runningBatcheIds","b","possibleLobbies","timedOutAt","$exists","fetch","lobby","indexOf","$in","exitAt","exitStatus","multi","i","lobbies","weigthedLobbyPool","weight","availableCount","$addToSet","includes"],"mappings":"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","sourcesContent":["// create.js\n\nimport moment from \"moment\";\n\nimport { Batches } from \"../batches/batches.js\";\nimport { GameLobbies } from \"../game-lobbies/game-lobbies.js\";\nimport { Games } from \"./games\";\nimport { PlayerRounds } from \"../player-rounds/player-rounds\";\nimport { PlayerStages } from \"../player-stages/player-stages\";\nimport { Players } from \"../players/players\";\nimport { Rounds } from \"../rounds/rounds\";\nimport { Stages } from \"../stages/stages\";\nimport { earlyExitGameLobby } from \"../game-lobbies/methods\";\nimport {\n  augmentPlayerStageRound,\n  augmentGameStageRound\n} from \"../player-stages/augment.js\";\nimport { augmentGameObject } from \"../games/augment.js\";\nimport { config } from \"../../server\";\nimport { weightedRandom } from \"../../lib/utils.js\";\nimport log from \"../../lib/log.js\";\nimport gameLobbyLock from \"../../gameLobby-lock.js\";\n\nconst addStageErrMsg = `\"round.addStage()\" requires an argument object with 3 properties:\n- name: internal name you'll use to write conditional logic in your experiment.\n- displayName: the name of the Stage the player will see in the UI.\n- durationInSeconds: the duration in seconds of the stage\n\ne.g.: round.addStage({\n  name: \"response\",\n  displayName: \"Response\",\n  durationInSeconds: 120\n});\n\n`;\n\nexport const createGameFromLobby = gameLobby => {\n  if (Games.find({ gameLobbyId: gameLobby._id }).count() > 0) {\n    return;\n  }\n\n  const players = gameLobby.players();\n\n  const batch = gameLobby.batch();\n  const treatment = gameLobby.treatment();\n  const factors = treatment.factorsObject();\n  const { batchId, treatmentId, status, debugMode } = gameLobby;\n\n  players.forEach(player => {\n    player.data = player.data || {};\n    player.set = (key, value) => {\n      player.data[key] = value;\n    };\n    player.get = key => {\n      return player.data[key];\n    };\n  });\n\n  // Ask (experimenter designer) init function to configure this game\n  // given the factors and players given.\n  const params = { data: { ...gameLobby.data }, rounds: [], players };\n  var gameCollector = {\n    players,\n    treatment: factors,\n\n    get(k) {\n      return params.data[k];\n    },\n\n    set(k, v) {\n      params.data[k] = v;\n    },\n\n    addRound(props) {\n      const data = props ? props.data : {} || {};\n      const round = { data, stages: [] };\n      params.rounds.push(round);\n      return {\n        get(k) {\n          return round.data[k];\n        },\n\n        set(k, v) {\n          round.data[k] = v;\n        },\n\n        addStage({ name, displayName, durationInSeconds, data = {} }) {\n          try {\n            if (!name || !displayName || !durationInSeconds) {\n              log.error(addStageErrMsg);\n              log.error(\n                `Got: ${JSON.stringify(\n                  { name, displayName, durationInSeconds },\n                  null,\n                  \"  \"\n                )}`\n              );\n              throw \"gameInit error\";\n            }\n\n            const durationInSecondsAsInt = parseInt(durationInSeconds);\n            if (\n              Number.isNaN(durationInSecondsAsInt) ||\n              durationInSecondsAsInt < 1\n            ) {\n              console.error(\n                `Error in addStage call: durationInSeconds must be an number > 0 (name: ${name})`\n              );\n            }\n\n            const stage = {\n              name,\n              displayName,\n              durationInSeconds: durationInSecondsAsInt\n            };\n            round.stages.push({ ...stage, data });\n            return {\n              ...stage,\n              get(k) {\n                return data[k];\n              },\n              set(k, v) {\n                data[k] = v;\n              }\n            };\n          } catch (error) {\n            earlyExitGameLobby.call({\n              exitReason: \"initError\",\n              gameLobbyId: gameLobby._id\n            });\n          }\n        }\n      };\n    }\n  };\n\n  try {\n    gameLobbyLock[gameLobby._id] = true;\n    config.gameInit(gameCollector, factors);\n  } catch (err) {\n    console.error(`fatal error encounter calling Empirica.gameInit:`);\n    console.error(err);\n    earlyExitGameLobby.call({\n      exitReason: \"gameError\",\n      gameLobbyId: gameLobby._id\n    });\n    return;\n  }\n\n  if (!params.rounds || params.rounds.length === 0) {\n    throw \"at least one round must be added per game\";\n  }\n\n  params.rounds.forEach(round => {\n    if (!round.stages || round.stages.length === 0) {\n      throw \"at least one stage must be added per round\";\n    }\n\n    round.stages.forEach(({ name, displayName, durationInSeconds }) => {\n      // This should never happen as we already verified it above.\n      if (!name || !displayName || !durationInSeconds) {\n        log.error(addStageErrMsg);\n        throw \"invalid stage\";\n      }\n    });\n  });\n\n  // Keep debug mode from lobby\n  params.debugMode = debugMode;\n\n  // We need to create/configure stuff associated with the game before we\n  // create it so we generate the id early\n  const gameId = gameLobby._id;\n  params._id = gameId;\n  params.gameLobbyId = gameLobby._id;\n  // We also add a few related objects\n  params.treatmentId = treatmentId;\n  params.batchId = batchId;\n  params.status = status;\n\n  // playerIds is the reference to players stored in the game object\n  params.playerIds = _.pluck(params.players, \"_id\");\n  // We then need to verify all these ids exist and are unique, the\n  // init function might not have returned them correctly\n  const len = _.uniq(_.compact(params.playerIds)).length;\n  if (len !== params.players.length || len !== players.length) {\n    throw new Error(\"invalid player count\");\n  }\n\n  // We want to copy over the changes made by the init function and save the\n  // gameId in the player objects already in the DB\n  params.players.forEach(({ _id, data }) => {\n    Players.update(\n      _id,\n      { $set: { gameId, data } },\n      {\n        autoConvert: false,\n        filter: false,\n        validate: false,\n        trimStrings: false,\n        removeEmptyStrings: false\n      }\n    );\n  });\n\n  // Create the round objects\n  let stageIndex = 0;\n  let totalDuration = 0;\n  let firstRoundId;\n\n  const insertOption = {\n    autoConvert: false,\n    filter: false,\n    validate: false,\n    trimStrings: false,\n    removeEmptyStrings: false\n  };\n\n  let StagesUpdateOp = Stages.rawCollection().initializeUnorderedBulkOp();\n  let RoundsOp = Rounds.rawCollection().initializeUnorderedBulkOp();\n  let StagesOp = Stages.rawCollection().initializeUnorderedBulkOp();\n  let roundsOpResult;\n  let stagesOpResult;\n\n  params.rounds.forEach((round, index) =>\n    RoundsOp.insert(\n      _.extend(\n        {\n          gameId,\n          index,\n          _id: Random.id(),\n          createdAt: new Date(),\n          data: {}\n        },\n        round\n      ),\n      insertOption\n    )\n  );\n\n  roundsOpResult = Meteor.wrapAsync(RoundsOp.execute, RoundsOp)();\n\n  const roundIds = roundsOpResult.getInsertedIds().map(ids => ids._id);\n  params.roundIds = roundIds;\n  RoundsOp = Rounds.rawCollection().initializeUnorderedBulkOp();\n\n  params.rounds.forEach((round, index) => {\n    const roundId = roundIds[index];\n    const { players } = params;\n\n    StagesOp = Stages.rawCollection().initializeUnorderedBulkOp();\n    let PlayerStagesOp = PlayerStages.rawCollection().initializeUnorderedBulkOp();\n    let PlayerRoundsOp = PlayerRounds.rawCollection().initializeUnorderedBulkOp();\n\n    round.stages.forEach(stage => {\n      if (batch.debugMode) {\n        stage.durationInSeconds = 60 * 60; // Stage time in debugMode is 1h\n      }\n\n      totalDuration += stage.durationInSeconds;\n\n      const sParams = _.extend(\n        {\n          gameId,\n          roundId,\n          index: stageIndex,\n          _id: Random.id(),\n          createdAt: new Date(),\n          data: {}\n        },\n        stage\n      );\n\n      StagesOp.insert(sParams, insertOption);\n\n      stageIndex++;\n    });\n\n    stagesOpResult = Meteor.wrapAsync(StagesOp.execute, StagesOp)();\n    const stageIds = stagesOpResult.getInsertedIds().map(ids => ids._id);\n\n    stageIds.forEach(stageId => {\n      if (!params.currentStageId) {\n        firstRoundId = roundId;\n        params.currentStageId = stageId;\n      }\n\n      players.forEach(({ _id: playerId }) =>\n        PlayerStagesOp.insert({\n          playerId,\n          stageId,\n          roundId,\n          gameId,\n          batchId,\n          _id: Random.id(),\n          createdAt: new Date(),\n          data: {}\n        })\n      );\n    });\n\n    const playerStagesResult = Meteor.wrapAsync(\n      PlayerStagesOp.execute,\n      PlayerStagesOp\n    )();\n    const playerStageIds = playerStagesResult\n      .getInsertedIds()\n      .map(ids => ids._id);\n\n    stageIds.forEach(stageId =>\n      StagesUpdateOp.find({ _id: stageId })\n        .upsert()\n        .updateOne({ $set: { playerStageIds, updatedAt: new Date() } })\n    );\n\n    players.forEach(({ _id: playerId }) =>\n      PlayerRoundsOp.insert({\n        playerId,\n        roundId,\n        gameId,\n        batchId,\n        _id: Random.id(),\n        data: {},\n        createdAt: new Date()\n      })\n    );\n\n    const playerRoundIdsResult = Meteor.wrapAsync(\n      PlayerRoundsOp.execute,\n      PlayerRoundsOp\n    )();\n    const playerRoundIds = playerRoundIdsResult\n      .getInsertedIds()\n      .map(ids => ids._id);\n\n    RoundsOp.find({ _id: roundId })\n      .upsert()\n      .updateOne({ $set: { stageIds, playerRoundIds, updatedAt: new Date() } });\n  });\n\n  Meteor.wrapAsync(StagesUpdateOp.execute, StagesUpdateOp)();\n  Meteor.wrapAsync(RoundsOp.execute, RoundsOp)();\n\n  // An estimation of the finish time to help querying.\n  // At the moment, this will 100% break with pausing the game/batch.\n  params.estFinishedTime = moment()\n    // Give it an extra 24h (86400s) window for the inter-stage sync buffer.\n    // It was 5 min and that failed on an experiment with many rounds.\n    // This value is not extremely useful, it's main purpose is currently\n    // to stop querying games indefinitely in the update game background job.\n    // It was also meant to be an approximate estimate for when the game could\n    // end at the maximum, that we could show in the admin, but it can no longer\n    // work, and it is questionable if the \"stop querying\" \"feature\" is still\n    // adequate.\n    .add(totalDuration + 86400, \"seconds\")\n    .toDate();\n\n  // We're no longer filtering out unspecified fields on insert because of a\n  // simpleschema bug, so we need to remove invalid params now.\n  delete params.players;\n  delete params.rounds;\n\n  // Insert game. As soon as it comes online, the game will start for the\n  // players so all related object (rounds, stages, players) must be created\n  // and ready\n  Games.insert(params, {\n    autoConvert: false,\n    filter: false,\n    validate: false,\n    trimStrings: false,\n    removeEmptyStrings: false\n  });\n\n  // Let Game Lobby know Game ID\n  GameLobbies.update(gameLobby._id, { $set: { gameId } });\n\n  //\n  // Overbooking\n  //\n\n  // Overbooked players that did not finish the intro and won't be in this game\n  const failedPlayerIds = _.difference(\n    gameLobby.queuedPlayerIds,\n    gameLobby.playerIds\n  );\n\n  sendPlayersToNextBatches(failedPlayerIds, batchId, gameLobby);\n\n  //\n  // Call the callbacks\n  //\n\n  const { onRoundStart, onGameStart, onStageStart } = config;\n  if ((onGameStart || onRoundStart || onStageStart) && firstRoundId) {\n    const game = Games.findOne(gameId);\n\n    augmentGameObject({\n      game,\n      treatment,\n      firstRoundId,\n      currentStageId: params.currentStageId\n    });\n\n    const nextRound = game.rounds.find(r => r._id === firstRoundId);\n    const nextStage = nextRound.stages.find(\n      s => s._id === params.currentStageId\n    );\n\n    augmentGameStageRound(game, nextStage, nextRound);\n\n    if (onGameStart) {\n      onGameStart(game);\n    }\n    if (onRoundStart) {\n      onRoundStart(game, nextRound);\n    }\n    if (onStageStart) {\n      onStageStart(game, nextRound, nextStage);\n    }\n  }\n\n  //\n  // Start the game\n  //\n\n  const startTimeAt = moment()\n    .add(Stages.stagePaddingDuration)\n    .toDate();\n\n  Stages.update(params.currentStageId, {\n    $set: {\n      startTimeAt\n    }\n  });\n\n  delete gameLobbyLock[gameLobby._id];\n};\n\nexport function sendPlayersToNextBatches(playerIds, batchId, gameLobby) {\n  // Find other lobbies that are not full yet with the same treatment\n  const runningBatches = Batches.find(\n    { _id: { $ne: batchId }, status: \"running\" },\n    { sort: { runningAt: 1 } }\n  );\n  const { treatmentId } = gameLobby;\n  const lobbiesGroups = runningBatches.map(() => []);\n  const runningBatcheIds = runningBatches.map(b => b._id);\n  lobbiesGroups.push([]);\n  const possibleLobbies = GameLobbies.find({\n    _id: { $ne: gameLobby._id },\n    status: \"running\",\n    timedOutAt: {\n      $exists: false\n    },\n    gameId: { $exists: false },\n    treatmentId\n  }).fetch();\n  possibleLobbies.forEach(lobby => {\n    if (lobby.batchId === batchId) {\n      lobbiesGroups[0].push(lobby);\n    } else {\n      lobbiesGroups[runningBatcheIds.indexOf(lobby.batchId) + 1].push(lobby);\n    }\n  });\n\n  // If no lobbies left, lead players to exit\n  if (possibleLobbies.length === 0) {\n    if (playerIds.length > 0) {\n      Players.update(\n        { _id: { $in: playerIds } },\n        { $set: { exitAt: new Date(), exitStatus: \"gameFull\" } },\n        { multi: true }\n      );\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < lobbiesGroups.length; i++) {\n    const lobbies = lobbiesGroups[i];\n\n    if (lobbies.length === 0) {\n      continue;\n    }\n\n    // If there are lobbies remaining, distribute them across the lobbies\n    // proportinally to the initial playerCount\n    const weigthedLobbyPool = weightedRandom(\n      lobbies.map(lobby => {\n        return {\n          value: lobby,\n          weight: lobby.availableCount\n        };\n      })\n    );\n\n    for (let i = 0; i < playerIds.length; i++) {\n      const playerId = playerIds[i];\n      const lobby = weigthedLobbyPool();\n\n      // Adding the player to specified lobby queue\n      const $addToSet = { queuedPlayerIds: playerId };\n      if (gameLobby.playerIds.includes(playerId)) {\n        $addToSet.playerIds = playerId;\n      }\n      GameLobbies.update(lobby._id, { $addToSet });\n\n      Players.update(playerId, {\n        $set: {\n          gameLobbyId: lobby._id\n        }\n      });\n    }\n\n    break;\n  }\n}\n"]},"sourceType":"module","hash":"cb1a3ce3fe90407a118d9d92a0f3a9f613fffe3a"}
