[{"type":"js","data":"/* Imports for global scope */\n\nMongoInternals = Package.mongo.MongoInternals;\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nECMAScript = Package.ecmascript.ECMAScript;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nWebAppInternals = Package.webapp.WebAppInternals;\nmain = Package.webapp.main;\nDDP = Package['ddp-client'].DDP;\nDDPServer = Package['ddp-server'].DDPServer;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nmeteorInstall = Package.modules.meteorInstall;\nPromise = Package.promise.Promise;\n_ = Package.underscore._;\nAutoupdate = Package.autoupdate.Autoupdate;\n\n","servePath":"/global-imports.js"},{"type":"js","data":"var require = meteorInstall({\"server\":{\"bots.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// server/bots.js                                                                                                //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\n// This is where you add bots, like Bob:\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {} // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n\n\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"callbacks.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// server/callbacks.js                                                                                           //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\nlet ALIGN_LEFT;\nmodule.link(\"@blueprintjs/core/lib/esm/common/classes\", {\n  ALIGN_LEFT(v) {\n    ALIGN_LEFT = v;\n  }\n\n}, 0);\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 1);\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart(game => {\n  game.players.forEach((player, i) => {\n    /*player.set(\"avatar\", `/avatars/jdenticon/${player._id}`);*/\n    player.set(\"avatar\", \"/avatars/\".concat(i, \".png\"));\n    player.set(\"avatarId\", i);\n    player.set(\"cumulativePayoff\", game.treatment.endowment);\n  });\n}); // onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\n\nEmpirica.onRoundStart((game, round) => {\n  round.set(\"totalContributions\", 0);\n  round.set(\"totalReturns\", 0);\n  round.set(\"payoff\", 0);\n  game.players.forEach((player, i) => {\n    player.round.set(\"endowment\", game.treatment.endowment);\n    player.round.set(\"punishedBy\", {});\n    player.round.set(\"contribution\", 0);\n    player.round.set(\"punished\", {});\n  });\n}); // onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\n\nEmpirica.onStageStart((game, round, stage) => {}); // onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\n\nEmpirica.onStageEnd((game, round, stage) => {\n  if (stage.name == \"contribution\") {\n    computePayoff(game, round);\n  } //player.stage.set values but wait to update until round end\n\n\n  if (stage.name == \"punishment\") {\n    computePunishmentCosts(game, round);\n    computeIndividualPayoff(game, round);\n  }\n}); // onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\n\nEmpirica.onRoundEnd((game, round) => {\n  game.players.forEach(player => {\n    const prevCumulativePayoff = player.get(\"cumulativePayoff\");\n    const roundPayoff = player.round.get(\"roundPayoff\");\n    const newCumulativePayoff = Math.round(prevCumulativePayoff + roundPayoff);\n    player.set(\"cumulativePayoff\", newCumulativePayoff);\n  });\n}); // onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\n\nEmpirica.onGameEnd(game => {\n  computeTotalPayoff(game);\n  convertPayoff(game);\n}); // compute each players' payoffs\n\nfunction computePayoff(game, round) {\n  const multiplier = game.treatment.multiplier;\n  let newTotalContributions = 0;\n  game.players.forEach(player => {\n    const contribution = player.round.get(\"contribution\");\n    newTotalContributions += parseFloat(contribution);\n  });\n  round.set(\"totalContributions\", newTotalContributions);\n  const multipliedReturns = Math.round(round.get(\"totalContributions\") * multiplier);\n  round.set(\"totalReturns\", multipliedReturns);\n  const totalReturns = round.get(\"totalReturns\");\n  const payoff = Math.round(totalReturns / game.players.length);\n  round.set(\"payoff\", payoff);\n}\n\nfunction computePunishmentCosts(game, round) {\n  game.players.forEach(player => {\n    const punished = player.round.get(\"punished\");\n    const punishedKeys = Object.keys(punished);\n    let cost = 0;\n\n    for (const key of punishedKeys) {\n      if (punished[key] != \"0\") {\n        amount = punished[key];\n        cost += parseFloat(amount);\n      } else {}\n    }\n\n    let punishedBy = {};\n    player.round.set(\"costs\", cost);\n\n    const otherPlayers = _.reject(game.players, p => p._id === player._id);\n\n    otherPlayers.forEach(otherPlayer => {\n      const otherPlayerPunished = otherPlayer.round.get(\"punished\");\n\n      if (Object.keys(otherPlayerPunished).includes(player._id)) {\n        punishedBy[otherPlayer._id] = otherPlayerPunished[player._id];\n        console.log(punishedBy);\n      }\n    });\n    player.round.set(\"punishedBy\", punishedBy);\n    punishedBy = player.round.get(\"punishedBy\");\n    let receivedPunishments = 0;\n    const punishedByKeys = Object.keys(punishedBy);\n\n    for (const key of punishedByKeys) {\n      if (punishedBy[key] != \"0\") {\n        amount = punishedBy[key];\n        receivedPunishments += parseFloat(amount);\n      }\n    }\n\n    const penalties = parseFloat(receivedPunishments) * game.treatment.punishment;\n    player.round.set(\"penalties\", penalties);\n  });\n} // computes players' individual payoff (round payoff minus punishment costs and penalties)\n\n\nfunction computeIndividualPayoff(game, round) {\n  game.players.forEach(player => {\n    const payoff = round.get(\"payoff\");\n    const contribution = player.round.get(\"contribution\");\n    const remainingEndowment = parseFloat(game.treatment.endowment) - parseFloat(contribution);\n    player.round.set(\"remainingEndowment\", remainingEndowment);\n    const penalties = player.round.get(\"penalties\");\n    const costs = player.round.get(\"costs\");\n    const roundPayoff = parseFloat(payoff) + parseFloat(remainingEndowment) - parseFloat(penalties) - parseFloat(costs);\n    player.round.set(\"roundPayoff\", roundPayoff);\n  });\n} // computes the total payoff across all players (measure of cooperation) //\n\n\nfunction computeTotalPayoff(game) {\n  let totalPayoff = 0;\n  game.players.forEach(player => {\n    const cumulativePayoff = player.get(\"cumulativePayoff\");\n    totalPayoff += parseFloat(cumulativePayoff);\n    game.set(\"totalPayoff\", totalPayoff);\n  });\n} // converts player's payoff to real money\n\n\nfunction convertPayoff(game) {\n  game.players.forEach(player => {\n    const cumulativePayoff = player.get(\"cumulativePayoff\");\n    let earnings = 0;\n\n    if (cumulativePayoff > 0) {\n      let earnings = parseFloat(cumulativePayoff) * game.treatment.conversionRate;\n    } else {}\n\n    player.set(\"earnings\", earnings);\n  });\n} // ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n// onSet is called when the experiment code call the .set() method\n// on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue // Previous value\n//   ) => {\n//     // // Example filtering\n//     // if (key !== \"value\") {\n//     //   return;\n//     // }\n//   }\n// );\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue // Previous value\n//   ) => {\n//     // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//     //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n//   }\n// );\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue, // Previous value\n//     isAppend // True if the change was an append, false if it was a set\n//   ) => {\n//     // `onChange` is useful to run server-side logic for any user interaction.\n//     // Note the extra isAppend boolean that will allow to differenciate sets and\n//     // appends.\n//     Game.set(\"lastChangeAt\", new Date().toString());\n//   }\n// );\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player // Player who submitted\n//   ) => {}\n// );\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"main.js\":function module(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                               //\n// server/main.js                                                                                                //\n//                                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                 //\nlet Empirica;\nmodule.link(\"meteor/empirica:core\", {\n  default(v) {\n    Empirica = v;\n  }\n\n}, 0);\nmodule.link(\"./bots.js\");\nmodule.link(\"./callbacks.js\");\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\n\n/*Empirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure,\n      numTaskRounds,\n      numSurveyRounds,\n      setSizeBasedOnPlayerCount,\n      userInactivityDuration,\n      taskDuration,\n      defaultSetSize,\n      surveyDuration,\n      resultsDuration,\n      maxNumOverlap,\n    },\n  } = game;\n\n*/\nEmpirica.gameInit(game => {\n  _.times(game.treatment.numRounds, i => {\n    const round = game.addRound();\n    round.addStage({\n      name: \"contribution\",\n      displayName: \"Contribution\",\n      durationInSeconds: game.treatment.contributionDuration\n    });\n\n    if (game.treatment.punishment > 0) {\n      round.addStage({\n        name: \"punishment\",\n        displayName: \"Punishment\",\n        durationInSeconds: game.treatment.punishmentDuration\n      });\n    }\n\n    round.addStage({\n      name: \"outcome\",\n      displayName: \"Outcome\",\n      durationInSeconds: game.treatment.outcomeDuration\n    });\n  });\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/server/main.js\");","hash":"f98565251cada45f944c843f1b372e28bf499f69","servePath":"/app.js","sourceMap":{"version":3,"sources":["server/bots.js","server/callbacks.js","server/main.js"],"names":["Empirica","module","link","default","v","bot","onStageTick","game","round","stage","secondsRemaining","ALIGN_LEFT","onGameStart","players","forEach","player","i","set","treatment","endowment","onRoundStart","onStageStart","onStageEnd","name","computePayoff","computePunishmentCosts","computeIndividualPayoff","onRoundEnd","prevCumulativePayoff","get","roundPayoff","newCumulativePayoff","Math","onGameEnd","computeTotalPayoff","convertPayoff","multiplier","newTotalContributions","contribution","parseFloat","multipliedReturns","totalReturns","payoff","length","punished","punishedKeys","Object","keys","cost","key","amount","punishedBy","otherPlayers","_","reject","p","_id","otherPlayer","otherPlayerPunished","includes","console","log","receivedPunishments","punishedByKeys","penalties","punishment","remainingEndowment","costs","totalPayoff","cumulativePayoff","earnings","conversionRate","gameInit","times","numRounds","addRound","addStage","displayName","durationInSeconds","contributionDuration","punishmentDuration","outcomeDuration"],"mappings":"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","file":"/app.js","sourcesContent":["import Empirica from \"meteor/empirica:core\";\n\n// This is where you add bots, like Bob:\n\nEmpirica.bot(\"bob\", {\n  // // NOT SUPPORTED Called at the beginning of each stage (after onRoundStart/onStageStart)\n  // onStageStart(bot, game, round, stage, players) {},\n\n  // Called during each stage at tick interval (~1s at the moment)\n  onStageTick(bot, game, round, stage, secondsRemaining) {}\n\n  // // NOT SUPPORTED A player has changed a value\n  // // This might happen a lot!\n  // onStagePlayerChange(bot, game, round, stage, players, player) {}\n\n  // // NOT SUPPORTED Called at the end of the stage (after it finished, before onStageEnd/onRoundEnd is called)\n  // onStageEnd(bot, game, round, stage, players) {}\n});\n","import { ALIGN_LEFT } from \"@blueprintjs/core/lib/esm/common/classes\";\nimport Empirica from \"meteor/empirica:core\";\n\n// onGameStart is triggered opnce per game before the game starts, and before\n// the first onRoundStart. It receives the game and list of all the players in\n// the game.\nEmpirica.onGameStart((game) => {\n  game.players.forEach((player, i) => {\n    /*player.set(\"avatar\", `/avatars/jdenticon/${player._id}`);*/\n    player.set(\"avatar\", `/avatars/${i}.png`);\n    player.set(\"avatarId\", i);\n    player.set(\"cumulativePayoff\", game.treatment.endowment);\n  });\n});\n\n// onRoundStart is triggered before each round starts, and before onStageStart.\n// It receives the same options as onGameStart, and the round that is starting.\nEmpirica.onRoundStart((game, round) => {\n  round.set(\"totalContributions\", 0);\n  round.set(\"totalReturns\", 0);\n  round.set(\"payoff\", 0);\n  game.players.forEach((player, i) => {\n    player.round.set(\"endowment\", game.treatment.endowment);\n    player.round.set(\"punishedBy\", {});\n    player.round.set(\"contribution\", 0);\n    player.round.set(\"punished\", {});\n  });\n});\n\n// onStageStart is triggered before each stage starts.\n// It receives the same options as onRoundStart, and the stage that is starting.\nEmpirica.onStageStart((game, round, stage) => {});\n\n// onStageEnd is triggered after each stage.\n// It receives the same options as onRoundEnd, and the stage that just ended.\nEmpirica.onStageEnd((game, round, stage) => {\n  if (stage.name == \"contribution\") {\n    computePayoff(game, round);\n  } //player.stage.set values but wait to update until round end\n  if (stage.name == \"punishment\") {\n    computePunishmentCosts(game, round);\n    computeIndividualPayoff(game, round);\n  }\n});\n\n// onRoundEnd is triggered after each round.\n// It receives the same options as onGameEnd, and the round that just ended.\nEmpirica.onRoundEnd((game, round) => {\n  game.players.forEach((player) => {\n    const prevCumulativePayoff = player.get(\"cumulativePayoff\");\n    const roundPayoff = player.round.get(\"roundPayoff\");\n    const newCumulativePayoff = Math.round(prevCumulativePayoff + roundPayoff);\n    player.set(\"cumulativePayoff\", newCumulativePayoff);\n  });\n});\n\n// onGameEnd is triggered when the game ends.\n// It receives the same options as onGameStart.\nEmpirica.onGameEnd((game) => {\n  computeTotalPayoff(game);\n  convertPayoff(game);\n});\n\n// compute each players' payoffs\nfunction computePayoff(game, round) {\n  const multiplier = game.treatment.multiplier;\n  let newTotalContributions = 0;\n  game.players.forEach((player) => {\n    const contribution = player.round.get(\"contribution\");\n    newTotalContributions += parseFloat(contribution);\n  });\n  round.set(\"totalContributions\", newTotalContributions);\n  const multipliedReturns = Math.round(\n    round.get(\"totalContributions\") * multiplier\n  );\n  round.set(\"totalReturns\", multipliedReturns);\n  const totalReturns = round.get(\"totalReturns\");\n  const payoff = Math.round(totalReturns / game.players.length);\n  round.set(\"payoff\", payoff);\n}\n\nfunction computePunishmentCosts(game, round) {\n  game.players.forEach((player) => {\n    const punished = player.round.get(\"punished\");\n    const punishedKeys = Object.keys(punished);\n    let cost = 0;\n    for (const key of punishedKeys) {\n      if (punished[key] != \"0\") {\n        amount = punished[key];\n        cost += parseFloat(amount);\n      } else {\n      }\n    }\n    let punishedBy = {};\n    player.round.set(\"costs\", cost);\n    const otherPlayers = _.reject(game.players, (p) => p._id === player._id);\n    otherPlayers.forEach((otherPlayer) => {\n      const otherPlayerPunished = otherPlayer.round.get(\"punished\");\n      if (Object.keys(otherPlayerPunished).includes(player._id)) {\n        punishedBy[otherPlayer._id] = otherPlayerPunished[player._id];\n        console.log(punishedBy);\n      }\n    });\n    player.round.set(\"punishedBy\", punishedBy);\n    punishedBy = player.round.get(\"punishedBy\");\n    let receivedPunishments = 0;\n    const punishedByKeys = Object.keys(punishedBy);\n    for (const key of punishedByKeys) {\n      if (punishedBy[key] != \"0\") {\n        amount = punishedBy[key];\n        receivedPunishments += parseFloat(amount);\n      }\n    }\n    const penalties =\n      parseFloat(receivedPunishments) * game.treatment.punishment;\n    player.round.set(\"penalties\", penalties);\n  });\n}\n\n// computes players' individual payoff (round payoff minus punishment costs and penalties)\nfunction computeIndividualPayoff(game, round) {\n  game.players.forEach((player) => {\n    const payoff = round.get(\"payoff\");\n    const contribution = player.round.get(\"contribution\");\n    const remainingEndowment =\n      parseFloat(game.treatment.endowment) - parseFloat(contribution);\n    player.round.set(\"remainingEndowment\", remainingEndowment);\n    const penalties = player.round.get(\"penalties\");\n    const costs = player.round.get(\"costs\");\n    const roundPayoff =\n      parseFloat(payoff) +\n      parseFloat(remainingEndowment) -\n      parseFloat(penalties) -\n      parseFloat(costs);\n    player.round.set(\"roundPayoff\", roundPayoff);\n  });\n}\n\n// computes the total payoff across all players (measure of cooperation) //\nfunction computeTotalPayoff(game) {\n  let totalPayoff = 0;\n  game.players.forEach((player) => {\n    const cumulativePayoff = player.get(\"cumulativePayoff\");\n    totalPayoff += parseFloat(cumulativePayoff);\n    game.set(\"totalPayoff\", totalPayoff);\n  });\n}\n\n// converts player's payoff to real money\nfunction convertPayoff(game) {\n  game.players.forEach((player) => {\n    const cumulativePayoff = player.get(\"cumulativePayoff\");\n    let earnings = 0;\n    if (cumulativePayoff > 0) {\n      let earnings =\n        parseFloat(cumulativePayoff) * game.treatment.conversionRate;\n    } else {\n    }\n    player.set(\"earnings\", earnings);\n  });\n}\n\n// ===========================================================================\n// => onSet, onAppend and onChange ==========================================\n// ===========================================================================\n\n// onSet, onAppend and onChange are called on every single update made by all\n// players in each game, so they can rapidly become quite expensive and have\n// the potential to slow down the app. Use wisely.\n\n// It is very useful to be able to react to each update a user makes. Try\n// nontheless to limit the amount of computations and database saves (.set)\n// done in these callbacks. You can also try to limit the amount of calls to\n// set() and append() you make (avoid calling them on a continuous drag of a\n// slider for example) and inside these callbacks use the `key` argument at the\n// very beginning of the callback to filter out which keys your need to run\n// logic against.\n\n// If you are not using these callbacks, comment them out so the system does\n// not call them for nothing.\n\n// onSet is called when the experiment code call the .set() method\n// on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onSet(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue // Previous value\n//   ) => {\n//     // // Example filtering\n//     // if (key !== \"value\") {\n//     //   return;\n//     // }\n//   }\n// );\n\n// // onAppend is called when the experiment code call the `.append()` method\n// // on games, rounds, stages, players, playerRounds or playerStages.\n// Empirica.onAppend(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue // Previous value\n//   ) => {\n//     // Note: `value` is the single last value (e.g 0.2), while `prevValue` will\n//     //       be an array of the previsous valued (e.g. [0.3, 0.4, 0.65]).\n//   }\n// );\n\n// // onChange is called when the experiment code call the `.set()` or the\n// // `.append()` method on games, rounds, stages, players, playerRounds or\n// // playerStages.\n// Empirica.onChange(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player, // Player who made the change\n//     target, // Object on which the change was made (eg. player.set() => player)\n//     targetType, // Type of object on which the change was made (eg. player.set() => \"player\")\n//     key, // Key of changed value (e.g. player.set(\"score\", 1) => \"score\")\n//     value, // New value\n//     prevValue, // Previous value\n//     isAppend // True if the change was an append, false if it was a set\n//   ) => {\n//     // `onChange` is useful to run server-side logic for any user interaction.\n//     // Note the extra isAppend boolean that will allow to differenciate sets and\n//     // appends.\n//     Game.set(\"lastChangeAt\", new Date().toString());\n//   }\n// );\n\n// // onSubmit is called when the player submits a stage.\n// Empirica.onSubmit(\n//   (\n//     game,\n//     round,\n//     stage,\n//     player // Player who submitted\n//   ) => {}\n// );\n","import Empirica from \"meteor/empirica:core\";\nimport \"./bots.js\";\nimport \"./callbacks.js\";\n\n// gameInit is where the structure of a game is defined.\n// Just before every game starts, once all the players needed are ready, this\n// function is called with the treatment and the list of players.\n// You must then add rounds and stages to the game, depending on the treatment\n// and the players. You can also get/set initial values on your game, players,\n// rounds and stages (with get/set methods), that will be able to use later in\n// the game.\n\n/*Empirica.gameInit(game => {\n  const {\n    treatment: {\n      playerCount,\n      networkStructure,\n      numTaskRounds,\n      numSurveyRounds,\n      setSizeBasedOnPlayerCount,\n      userInactivityDuration,\n      taskDuration,\n      defaultSetSize,\n      surveyDuration,\n      resultsDuration,\n      maxNumOverlap,\n    },\n  } = game;\n\n*/\nEmpirica.gameInit((game) => {\n  _.times(game.treatment.numRounds, (i) => {\n    const round = game.addRound();\n\n    round.addStage({\n      name: \"contribution\",\n      displayName: \"Contribution\",\n      durationInSeconds: game.treatment.contributionDuration,\n    });\n\n    if (game.treatment.punishment > 0) {\n      round.addStage({\n        name: \"punishment\",\n        displayName: \"Punishment\",\n        durationInSeconds: game.treatment.punishmentDuration,\n      });\n    }\n    round.addStage({\n      name: \"outcome\",\n      displayName: \"Outcome\",\n      durationInSeconds: game.treatment.outcomeDuration,\n    });\n  });\n});\n"]}}]